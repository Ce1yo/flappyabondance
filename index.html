<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird</title>
    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.0/firebase-app.js';
      import { 
        getAuth, 
        signInWithEmailAndPassword, 
        createUserWithEmailAndPassword, 
        onAuthStateChanged,
        signOut
      } from 'https://www.gstatic.com/firebasejs/9.6.0/firebase-auth.js';
      import { getDatabase, ref, push, onValue, off, query, orderByChild, limitToLast } from 'https://www.gstatic.com/firebasejs/9.6.0/firebase-database.js';
      import { getAnalytics } from 'https://www.gstatic.com/firebasejs/9.6.0/firebase-analytics.js';

      const firebaseConfig = {
        apiKey: "AIzaSyDrj-Ka5VbRUlxhjL5Rl4JaX8IPMU1iqkE",
        authDomain: "flappy-abondance.firebaseapp.com",
        databaseURL: "https://flappy-abondance-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "flappy-abondance",
        storageBucket: "flappy-abondance.appspot.com",
        messagingSenderId: "304017778345",
        appId: "1:304017778345:web:24ff495a05435048a0abb8",
        measurementId: "G-XPGG6RQ2Z9"
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getDatabase(app);
      const analytics = getAnalytics(app);

      // Create global firebaseInstance
      window.firebaseInstance = {
        app,
        auth,
        db,
        signIn: (email, password) => signInWithEmailAndPassword(auth, email, password),
        signUp: (email, password) => createUserWithEmailAndPassword(auth, email, password),
        signOut: () => signOut(auth),
        onAuthStateChanged: (callback) => onAuthStateChanged(auth, callback),
        dbRef: (path) => ref(db, path),
        dbPush: push,
        dbQuery: query,
        dbOrderByChild: orderByChild,
        dbLimitToLast: limitToLast,
        dbOnValue: onValue,
        dbOff: off
      };

      // Wait for Firebase to initialize before starting the game
      window.addEventListener('load', () => {
        // Game code starts here
        (function() {
          // Gestion de l'authentification
          let isLoginMode = true;
          const authForm = document.getElementById('authForm');
          const userInfo = document.getElementById('userInfo');
          const authButton = document.getElementById('authButton');
          const authToggle = document.getElementById('authToggle');
          const authError = document.getElementById('authError');
          const emailInput = document.getElementById('emailInput');
          const passwordInput = document.getElementById('passwordInput');
          const userEmail = document.getElementById('userEmail');
          const logoutButton = document.getElementById('logoutButton');
          const gameContainer = document.getElementById('gameContainer');

          // Basculer entre connexion et inscription
          authToggle.addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            authButton.textContent = isLoginMode ? 'Se connecter' : 'Créer un compte';
            authToggle.textContent = isLoginMode ? 
              'Pas encore de compte ? Créer un compte' : 
              'Déjà un compte ? Se connecter';
            authError.textContent = '';
          });

          // Gérer la connexion/inscription
          authButton.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;

            try {
              if (isLoginMode) {
                await window.firebaseInstance.signIn(email, password);
              } else {
                await window.firebaseInstance.signUp(email, password);
              }
              authError.textContent = '';
            } catch (error) {
              console.error('Erreur d\'authentification:', error);
              authError.textContent = error.message;
            }
          });

          // Gérer la déconnexion
          logoutButton.addEventListener('click', async () => {
            try {
              await window.firebaseInstance.signOut();
            } catch (error) {
              console.error('Erreur de déconnexion:', error);
            }
          });

          // Observer les changements d'état d'authentification
          window.firebaseInstance.onAuthStateChanged((user) => {
            if (user) {
              // Utilisateur connecté
              authForm.style.display = 'none';
              userInfo.style.display = 'block';
              gameContainer.style.display = 'block';
              userEmail.textContent = user.email;
              
              // Initialiser le jeu avec l'email comme nom du joueur
              if (window.game) {
                window.game.playerName = user.email;
              } else {
                window.game = new FlappyGame(user.email);
              }
            } else {
              // Utilisateur déconnecté
              authForm.style.display = 'block';
              userInfo.style.display = 'none';
              gameContainer.style.display = 'none';
              emailInput.value = '';
              passwordInput.value = '';
            }
          });

          class FlappyGame {
            constructor(playerEmail) {
              this.playerName = playerEmail;
              this.canvas = document.getElementById('gameCanvas');
              if (!this.canvas) {
                console.error('Canvas element not found');
                return;
              }
              
              this.ctx = this.canvas.getContext('2d');
              this.resizeCanvas();
              this.bindResizeEvent();
              
              // Initialiser la base de données
              this.db = window.firebaseInstance.db;
              
              // Charger l'image du joueur
              this.playerImage = new Image();
              this.playerImage.src = 'https://cdn.shopify.com/s/files/1/0911/3894/9465/files/abondance.png?v=1743032067';
              this.playerImage.onload = () => {
                this.init();
                this.updateLeaderboard();
              };
            }

            resizeCanvas() {
              const container = this.canvas.parentElement;
              const rect = container.getBoundingClientRect();
              this.canvas.width = rect.width;
              this.canvas.height = rect.height;
              
              // Ajuster la taille du joueur en maintenant le ratio 4:1
              const baseSize = Math.min(this.canvas.width, this.canvas.height) * 0.075;
              this.playerWidth = baseSize * 4;
              this.playerHeight = baseSize;
              this.obstacleWidth = Math.min(this.canvas.width, this.canvas.height) * 0.083;
            }

            bindResizeEvent() {
              let resizeTimeout;
              window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                  this.resizeCanvas();
                  this.adjustGameElements();
                }, 250);
              });
            }

            adjustGameElements() {
              if (this.player) {
                this.player.width = this.playerWidth;
                this.player.height = this.playerHeight;
                this.player.x = this.canvas.width * 0.167;
              }
            }

            init() {
              this.player = {
                x: this.canvas.width * 0.167,
                y: this.canvas.height / 2,
                width: this.playerWidth,
                height: this.playerHeight,
                velocity: 0,
                gravity: this.canvas.height * 0.0015,
                jumpForce: -this.canvas.height * 0.03
              };

              this.obstacles = [];
              this.obstacleTimer = 0;
              this.obstacleInterval = 1500;
              this.lastObstacleTime = 0;
              
              this.score = 0;
              this.highScore = parseInt(localStorage.getItem('flappyHighScore')) || 0;
              this.gameOver = false;
              this.gameStarted = false;
              
              this.updateHighScoreDisplay();
              this.bindEvents();
              this.drawStartScreen();
            }

            updateHighScoreDisplay() {
              const highScoreElement = document.getElementById('highScore');
              if (highScoreElement) {
                highScoreElement.textContent = `Meilleur Score: ${this.highScore}`;
              }
            }

            bindEvents() {
              const handleAction = (e) => {
                if (e && e.preventDefault) {
                  e.preventDefault();
                }
                
                if (!this.gameStarted) {
                  this.startGame();
                } else if (!this.gameOver) {
                  this.player.velocity = this.player.jumpForce;
                } else {
                  this.init();
                  this.startGame();
                }
              };
      
              window.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.code === 'ArrowUp') {
                  handleAction(e);
                }
              });
      
              this.canvas.addEventListener('click', handleAction);
              this.canvas.addEventListener('touchstart', handleAction);
              
              const jumpButton = document.getElementById('jumpButton');
              if (jumpButton) {
                jumpButton.addEventListener('click', handleAction);
              }
              
              this.canvas.focus();
            }

            handleJump() {
              this.player.velocity = this.player.jumpForce;
            }

            startGame() {
              if (!this.playerName || !this.db) {
                console.error('Impossible de démarrer le jeu - non connecté');
                return;
              }

              this.gameStarted = true;
              this.gameOver = false;
              this.score = 0;
              this.obstacles = [];
              this.player.y = this.canvas.height / 2;
              this.player.velocity = 0;
              this.updateScore();
              this.animate();
            }

            resetGame() {
              this.startGame();
            }

            updateScore() {
              const scoreElement = document.getElementById('currentScore');
              if (scoreElement) {
                scoreElement.textContent = `Score: ${this.score}`;
              }
            }

            updateObstacles() {
              const now = Date.now();
              if (now - this.lastObstacleTime > this.obstacleInterval) {
                this.createObstacle();
                this.lastObstacleTime = now;
              }
      
              const speed = this.canvas.width * 0.008;
              for (let i = this.obstacles.length - 1; i >= 0; i--) {
                const obstacle = this.obstacles[i];
                obstacle.x -= speed;
      
                if (obstacle.x + obstacle.width < 0) {
                  this.obstacles.splice(i, 1);
                } else if (!obstacle.passed && obstacle.x + obstacle.width < this.player.x) {
                  obstacle.passed = true;
                  if (i % 2 === 0) {
                    this.score++;
                    this.updateScore();
                  }
                }
              }
            }

            checkCollision() {
              const playerHitbox = {
                x: this.player.x,
                y: this.player.y,
                width: this.player.width,
                height: this.player.height
              };

              // Vérifier les collisions avec les obstacles
              const hasCollision = this.obstacles.some(obstacle => (
                playerHitbox.x < obstacle.x + obstacle.width &&
                playerHitbox.x + playerHitbox.width > obstacle.x &&
                playerHitbox.y < obstacle.y + obstacle.height &&
                playerHitbox.y + playerHitbox.height > obstacle.y
              ));

              // On ne vérifie que les collisions avec les obstacles et le haut du canvas
              if (hasCollision || this.player.y <= 0) {
                console.log('Collision détectée! Score final:', this.score);
                this.gameOver = true;
                this.handleGameOver();
                return true;
              }
              return false;
            }

            handleGameOver() {
              if (this.score > this.highScore) {
                localStorage.setItem('flappyHighScore', this.score);
                this.highScore = this.score;
                this.updateHighScoreDisplay();
              }
            }

            update() {
              if (this.gameOver) return;

              this.player.velocity += this.player.gravity;
              this.player.y += this.player.velocity;

              // Empêcher le joueur de sortir du canvas par le haut
              if (this.player.y < 0) {
                this.player.y = 0;
                this.player.velocity = 0;
              }
              // Empêcher le joueur de sortir du canvas par le bas (sans game over)
              else if (this.player.y + this.player.height > this.canvas.height) {
                this.player.y = this.canvas.height - this.player.height;
                this.player.velocity = 0;
              }

              this.updateObstacles();
              this.checkCollision();
            }

            drawStartScreen() {
              this.ctx.fillStyle = '#fff';
              this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
              
              this.ctx.fillStyle = '#000';
              this.ctx.font = `${this.canvas.width * 0.05}px Arial`;
              this.ctx.textAlign = 'center';
              this.ctx.fillText('Cliquez pour commencer', this.canvas.width / 2, this.canvas.height / 2);
            }

            draw() {
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              
              // Dessiner le joueur avec l'image en respectant le ratio
              this.ctx.save();
              this.ctx.translate(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
              this.ctx.rotate(Math.min(Math.max(this.player.velocity * 0.05, -Math.PI / 6), Math.PI / 6));
              this.ctx.drawImage(
                this.playerImage,
                -this.player.width / 2,
                -this.player.height / 2,
                this.player.width,
                this.player.height
              );
              this.ctx.restore();

              this.ctx.fillStyle = '#000';
              for (const obstacle of this.obstacles) {
                this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
              }

              if (this.gameOver) {
                this.ctx.fillStyle = '#000';
                this.ctx.font = `${this.canvas.width * 0.05}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over - Cliquez pour recommencer', this.canvas.width / 2, this.canvas.height / 2);
              }
            }

            animate() {
              if (this.gameStarted) {
                this.update();
                this.draw();
                if (!this.gameOver) {
                  requestAnimationFrame(() => this.animate());
                }
              }
            }
          }
  
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new FlappyGame());
          } else {
            new FlappyGame();
          }
        })();
      });
    </script>
    <style>
.game-wrapper {
  margin: 20px auto;
  max-width: 800px;
  width: 100%;
  padding: 0 15px;
  box-sizing: border-box;
}

.game-container {
  width: 100%;
  margin: 0 auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.game-section {
  position: relative;
  margin-bottom: 20px;
  background: #fff;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  width: 100%;
  max-width: 600px;
}

.canvas-container {
  position: relative;
  width: 100%;
  padding-bottom: 66.67%; /* Ratio 3:2 */
}

#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 2px solid #000;
  border-radius: 8px;
  cursor: pointer;
}

.controls-info {
  margin-top: 10px;
  text-align: center;
}

.jump-button {
  display: inline-block;
  margin-top: 10px;
  padding: 8px 20px;
  background-color: #000;
  color: white;
  border: 2px solid #000;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.3s;
}

.jump-button:hover {
  background-color: white;
  color: #000;
}

.jump-button:active {
  background-color: #333;
  color: white;
}

.info-section {
  width: 100%;
  max-width: 600px;
  text-align: center;
}

.score-container {
  margin-bottom: 20px;
  font-size: 1.2em;
  background: #fff;
  padding: 15px;
  border-radius: 8px;
  border: 2px solid #000;
}

@media (max-width: 768px) {
  .game-wrapper {
    padding: 0 10px;
  }
  
  .game-container {
    padding: 10px;
  }
  
  .controls-info {
    font-size: 14px;
  }
  
  .score-container {
    font-size: 1em;
    padding: 10px;
  }
}
</style>
</head>
<body>
    <div class="game-wrapper">
        <div class="page-width">
            <!-- Conteneur d'authentification -->
            <div class="auth-container" id="authContainer">
                <div id="authForm">
                    <h2>Connexion</h2>
                    <form class="auth-form" onsubmit="return false;">
                        <input type="email" id="emailInput" class="auth-input" placeholder="Email" required>
                        <input type="password" id="passwordInput" class="auth-input" placeholder="Mot de passe" required>
                        <button id="authButton" class="auth-button">Se connecter</button>
                    </form>
                    <p class="auth-toggle" id="authToggle">
                        Pas encore de compte ? Créer un compte
                    </p>
                    <p class="auth-error" id="authError"></p>
                </div>
                <div id="userInfo" style="display: none;">
                    <p>Connecté en tant que : <span id="userEmail"></span></p>
                    <button id="logoutButton" class="logout-button">Se déconnecter</button>
                </div>
            </div>

            <!-- Conteneur du jeu (caché jusqu'à la connexion) -->
            <div id="gameContainer" class="game-container" style="display: none;">
                <div class="game-section">
                    <div class="canvas-container">
                        <canvas id="gameCanvas" tabindex="0"></canvas>
                    </div>
                    <div class="controls-info">
                        <button id="jumpButton" class="jump-button">Sauter</button>
                    </div>
                </div>
                <div class="info-section">
                    <div class="score-container">
                        <div id="currentScore">Score: 0</div>
                        <div id="highScore">Meilleur Score: 0</div>
                    </div>
                    <div id="leaderboardList" class="leaderboard-container"></div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>